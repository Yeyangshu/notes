## 为什么要实现双亲委派模型？

安全

## 解释一下对象的创建过程

1. 第一步将class 加载到内存

2. 第二步linking的过程
   - verification校验
   - preparation把类的静态变量设置默认值
   - resolution做解析
3. 类的初始化吧静态变量设为初始值同时执行静态语句块
4. 申请对象内存
5. 成员变量赋默认值
6. 调用构造方法`<init>` 
   - 成员变量顺序赋初始值
   - 执行构造方法语句

## 对象在内存中的存储布局？

对象的内存布局分为两类：

1. 普通对象

   - 对象头，在Hotspot里面称为markword，8个字节

   - ClassPointer指针：-XX:+UseCompressedClassPointers为4个字节，不开启为8个字节

   - 实例数据：

     - 引用类型：-XX:+UseCompressedOops为四个字节，不开启为8个字节，Oops（Ordinary Object Pointers）

     - 成员变量大小

       | Primitive Type | Memory Required(bytes) |
       | -------------- | ---------------------- |
       | boolean        | 1                      |
       | byte           | 1                      |
       | short          | 2                      |
       | char           | 2                      |
       | int            | 4                      |
       | float          | 4                      |
       | long           | 8                      |
       | double         | 8                      |

   - Padding对齐，是8的倍数

   普通对象，首先有一个对象头markword，8个字节，第二这个对象是属于哪个class的，ClassPointer指针指向你要的class对象，实例数据就是成员变量还有引用类型，第四个Padding对齐，算出来正好是15个字节，64位机器按照块来读取，所以是8的倍数

2. 数组对象

   - 对象头，8
   - ClassPointer指针
   - 数组长度：4字节
   - 数组数据
   - 对齐8的倍数

## 对象头具体包括什么？

简单参考文档：https://www.jianshu.com/p/91e398d5d17c

每个版本实现都不一样，markword的结构，定义在markOop.hpp文件

MarkWord里面有什么？MarkWord记录了对象和锁有关的信息，第一锁信息代表对象有没有被锁定，，第二GC的标记记录了分代年龄

## 对象怎么定位？

摘自《深入理解Java虚拟机》

创建对象自然是为了后续使用该对象，Java程序会通过栈上的refrence数据来操作栈上的具体对象。refrence类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以访问对象方式也是由虚拟机实现而定的，直流的访问方式有两种：

1. 句柄池

   如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，refrence中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息，**有图**

2. 直接指针

   如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，refrence中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要间接访问的开销，有图

这两种访问方式各有优势，使用句柄来访问最大的好处就是refrence中存储的是稳定句柄地址，在对象被移动（垃圾回收的时候移动对象是非常普遍的）时只会改变句柄中的实例数据指针，而refrence本身不需要被修改。使用直接指针来访问的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。Hotspot主要使用第二种方式进行对象定位，但是从整个软件开发的范围来看，在各类语言、框架中使用句柄来访问的情况也是非常常见的。

## 对象怎么分配？

## Object o = new Object在内存中占用了多少字节？

书58-59