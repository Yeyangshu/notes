# GC collector

## 1 什么是垃圾

垃圾：没有引用指向的任何对象都叫做垃圾

## 2 如何找到垃圾

### 2.1 引用计数算法（Refrence Counting）

引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用他，计数器值加1；当引用失效时，计数器就减1

主流Java虚拟机没有使用引用计数器来管理内存，最主要的原因是它很难解决对象之间互相循环引用的问题。            

### 2.2 可达性分析算法（Reachability Analysis）

可达性分析算法：通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象时不可用的

在Java语言中，可作为GC Roots的对象包括下面几种（背）：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法中JNI（Native方法）引用的对象

根对象：当一个程序马上启动的时候需要的对象

## 3 垃圾回收算法（背）

### 3.1 分带收集理论

当前商业的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。

2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；

#### 3.1.1 回收类型名词

- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：

- 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。

- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。

- 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

垃圾回收算法有三种：

1. 标记-清除算法
2. 复制算法
3. 标记-整理算法

### 3.2 标记-清除算法（Mark-Sweep）

![image-20201114224552331](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224552331.png)

算法分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。

标记清除算法需要经过两遍扫描，第一遍扫描那些有用的对象，标记没用的对象，第二遍扫描是把那些没用的找出来清理掉。

不足：

- 效率问题：标记和清除两个过程效率都不高
- 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象的时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。

### 3.3 复制算法（Copying）

![image-20201114224608288](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224608288.png)

为了解决效率问题，“复制算法出现了”，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不需要考虑内存碎片等复杂情况。

适用于存活对象较少的情况，只需要扫描一次，效率提高没有碎片，没有空间浪费，移动复制对象，只需要调整对应对象引用。

不足：

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将变低。

### 3.4 标记-整理算法（Mark-Compact）

![image-20201114224631078](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224631078.png)

标记所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

### 3.5 对象分配

#### 3.5.1 内存分配

##### 3.5.1.1 栈上分配

栈上分配：为了减少临时对象在堆内分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。

- **线程私有**的**小**对象
- 无逃逸：某一段代码中使用，使用完这段代码就没人认识
- 支持标量替换：用普通的属性代替对象
  - 标量和聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。
  - 替换过程：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。

**无需做出调整**

##### 3.5.1.2 线程本地分配 TLAB

TLAB（Thread Local Allocation Buffer）

TLAB全称Thread Local Alloc Buffer，是线程的一块私有内存，如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用，这个申请动作还是需要原子操作的。

TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，均摊对GC堆（eden区）里共享的分配指针做更新而带来的同步开销。

TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。

**无需做出调整**

##### 3.5.1.3 对象何时进入老年代？

###### 3.5.1.3.1 超过YGC次数

通过`XX:MaxTenuringThreshold`指定次数，默认次数：

- Parallel Scavenge：15次
- CMS：6次
- G1：15次

###### 3.5.1.3.2 动态年龄

虚拟机并不是永远地要求对象的年龄必须达到了`MaxTenuringThreshold`才能晋升老年代，如果在`Survivor`空间中相同年龄所有对象的大小的总和大于`Survivor`空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到`MaxTenuringThreshold`中要求的年龄。

#### 3.5.2 对象分配总结                                                                              

开始new一个对象，首先会在栈上分配，如果能够在栈上分配直接分配，如果分配不下，就会判断对象大不大（通过`-XX:PretenureSizeThreshold`指定），如果特别大直接进入`old`区，如果不够大，会进TLAB，到伊甸区，进行GC清除，如果清除完毕结束，如果没有清除进`s1`，`s1`在进行GC清除的时候，如果年龄够大进入`old`区，如果不够进入`s2`区。

![image-20201114203131662](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114203131662.png)

## 4 垃圾收集器

官网：https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm#JSGCT-GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304

### 4.1 常见的垃圾收集器

![image-20201114223351343](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114223351343.png)

垃圾回收器总结：

![image-20201114203438455](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114203438455.png)

常见的垃圾回收器分为三种：

- 新生代垃圾收集器
- 老年代垃圾收集器
- 新生代和老年代垃圾收集器

#### 4.1.1 新生代垃圾收集器

- Serial
- PraNew
- Parallel Scavenge

#### 4.1.2 老年代垃圾收集器

- Serial Old
- Parallel Old
- CMS

#### 4.1.3 新生代和老年代均适用

- G1收集器

### 4.2 垃圾收集器详解

#### 4.2.1 Serial-复制算法

![image-20201114224820687](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224820687.png)

单线程收集器，采用复制算法，在进行垃圾回收收集时，必须暂停其他所有的工作线程，直到它收集结束。

“Stop the world”：虚拟机后台自动发起，在用户不可见的情况下吧用户正常工作的线程全部停掉。

“Safe point”：线程停止（需要找一个安全点上线程停止），因为停止时间长，所以Serial使用的比较少。

#### 4.2.2 ParNew-复制算法

![image-20201114224838832](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224838832.png)

ParNew收集器是Serial收集器的多线程版本

除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。

#### 4.2.3  Parallel[ˈpærəlel] Scavenge[ˈskævɪndʒ]-复制算法

新生代收集器，使用复制算法，并行的多线程收集器

#### 4.2.4 Serial Old-标记整理算法

![image-20201114224910801](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224910801.png)

Serial收集器的老年代版本，使用单线程和标记-整理算法

#### 4.2.5 Parallel Old

![image-20201114224920247](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224920247.png)

Parallel Scavenge的老年代版本，使用多线程和标记-整理算法

#### 4.2.6 CMS收集器-标记清除算法

![image-20201114224955495](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201114224955495.png)

CMS（Concurrent Mark Sweep）收集器是一种以获得最短时间回收停顿时间为目标的收集器。

使用标记-清除算法

并发标记，并发清除

运作过程：

- 初始标记（）
- 并发标记（）
- 重新标记（）
- 并发清除（）

为什么会产生并发的垃圾回收器？

并发垃圾回收是因为无法忍受STW。





