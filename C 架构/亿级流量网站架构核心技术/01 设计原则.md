# 设计原则

## 1 高并发设计原则

### 1.1 无状态

无状态容易进行水平扩展。

实际生产环境：应用无状态+配置文件有状态

### 1.2 拆分

系统拆分几种情况：

- 系统维度：系统功能、业务拆分，比如商品系统、购物陈、结算、订单系统等。
- 功能维度：对一个系统进行功能再拆分，比如，优惠券系统可以拆分为后台券创建系统、领券系统、用券系统。
- 读写维度：读量大，使用缓存提升性能；写量大，分库分表。
- AOP 维度：比如，商品详情页可以分为 CDN、页面渲染系统。
- 模块维度：代码（Web、Service、Dao）

### 1.3 服务化

总结为如下流程：

进程内服务 -> 单机远程服务 -> 集群手动注册服务 -> 自动注册服务和发现服务 -> 服务的分组/隔离/路由 -> 服务治理如限流/黑白名单

### 1.4 消息队列

服务解耦（一对多）消费、异步处理、流量削峰/缓冲等。

#### 1.4.1 大流量缓冲

牺牲强一致性，保证最终一致性

#### 1.4.2 数据校对

消息异步机制场景下，可能存在消息的丢失，需要考虑进行数据校对和修正数据来保证一致性和完整性。

### 1.5 数据异构

#### 1.5.1 数据异构

#### 1.5.2 数据闭环

### 1.6 缓存银弹

| 流程节点       | 缓存技术                         |
| -------------- | -------------------------------- |
| 客户端         | 使用浏览器缓存                   |
|                | 客户端缓存                       |
| 客户端网络     | 代理服务器开启缓存               |
| 广域网         | 使用代理服务器（含 CDN）         |
|                | 使用镜像服务器                   |
|                | 使用 P2P 技术                    |
| 源站及源站网络 | 使用接入层提供的缓存机制         |
|                | 使用应用层提供的缓存机制         |
|                | 使用分布式缓存                   |
|                | 静态化、伪静态化                 |
|                | 使用服务器操作系统提供的缓存机制 |

#### 1.6.1 浏览器端缓存

设置请求的过期时间。如对响应头 Expires、Cahce-control 进行控制。

适用于实时性不太敏感的数据，如商品详情页、商家评分、评价、广告词等。

#### 1.6.2 APP 客户端缓存

大促前提前下发素材到客户端缓存。

#### 1.6.3 CDN 缓存

有些页面、活动页、图片等服务推送到离用户最近的 CDN 节点

- 推送机制
- 拉取机制

#### 1.6.4 接入层缓存

对于没有 CDN 缓存的应用来说，可以使用如 Nginx 搭建一层接入层。

#### 1.6.5 应用层缓存

使用 Tomcat 时，可以使用堆内缓存/堆外缓存。可以使用 local redis cache 来代替对外缓存；或在接入层使用 share_dict 来将缓存前置，以减少风暴。

#### 1.6.6 分布式缓存

数据量太大，Redis 单服务器存储不了，可以使用分片机制将流量分散到多台，或直接使用分布式缓存实现。

### 1.7 并发化

## 2 高可用原则

### 2.1 降级

设计降级开关

### 2.2 限流

限流的目的是防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值。

思路：

1. 恶意请求流量只访问到 cache。
2. 对于穿透到后端应用的流量可以考虑使用 Nginx 的 limit 模块处理。
3. 对于恶意的 IP 可以使用 nginx deny 进行屏蔽。

### 2.3 切流量

### 2.4 可回滚

## 3 业务设计原则

### 3.1 防重设计

### 3.2 幂等设计

### 3.3 流程可定义

### 3.4 状态与状态机

### 3.5 后台系统操作可反馈

### 3.6 后台系统审批化

### 3.7 文档和注释