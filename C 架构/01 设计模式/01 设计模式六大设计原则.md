# 六大设计原则

## 1 单一职责原则【Single Responsibility Principle】

单一职责原则Single Responsibility Principle，简称是SRP

### 1.1 单一职责原则定义

单一职责原则的英文原话是：There should never be more than one reason for a class to change.

意思是：一个类，应当只有一个引起它变化的原因；即**一个类应该只有一个职责**。

就一个类而言，应该只专注于做一件事和仅有一个引起变化的原因，这就是所谓的单一职责原则。该原则提出了对对象职责的一种理想期望，对象不应该承担太多职责。唯有专注，才能保证对象的高内聚；唯有单一，才能保证对象的细粒度。对象的高内聚与细粒度有利于对象的重用。一个庞大的对象承担了太多的职责，当客户端需要该对象的某一个职责时，就不得不将所有的职责都包含进来，从而造成冗余代码。

单一职责员原则的优点有以下：

- 降低类的复杂性
- 提高类的可读性
- 提高代码的可维护性和复用性
- 降低因变更引起的风险

### 1.2 单一职责的应用

比如`Person`类，代表一个人

使用`PersonManager`来负责对人的管理



做到**高内聚、低耦合**

## 2 开闭原则

开闭原则的英文名称是Open-Closed Principle，简称OCP。

### 2.1 开闭原则的定义

开闭原则的英文原文是：Software entities should be open for extension,but closed for modification.

意思是：一个软件实体应当**对外拓展开放，对修改关闭**

这个原则说的是，在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即**应当可以在不必修改源代码的情况下改变这个模块的行为。**	

在面向对象的编程中，开闭原则是最基础的原则，起到总的指导作用，其他原则（单一职责、里氏替换、依赖倒置、接口隔离、迪米特法则）都是开闭原则的具体形态，即其他原则都是开闭原则的手段和工具。

开闭原则的重要性可以通过以下几个方面来体现：

- 开闭原则提高复用性。在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑，代码粒度越小，被复用的可能性就越大，避免相同的逻辑重复增加。开闭原则的设计保证系统是一个在高层次上实现了复用的系统。

- 开闭原则提高可维护性。一个软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能对程序进行扩展，就是扩展一个类，而不是修改一个类。开闭原则对已有软件模块，特别是最重要的抽象层模块要求不能再修改，这就使变化中的软件系统有一定的稳定性和延续性，便于系统的维护。

- 开闭原则提高灵活性。所有的软件系统都有一个共同的性质，即对系统的需求都会随时间的推移而发生变化。在软件系统面临新的需求时，系统的设计必须是稳定的。开闭原则可以通过扩展已有的软件系统，提供新的行为，能快速应对变化，以满足对软件新的需求，使变化中的软件系统有一定的适应性和灵活性。

- 开闭原则易于测试。测试是软件开发过程中必不可少的一个环节。测试代码不仅要保证逻辑的正确性，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码”（Poisonous Code），因此当有变化提出时，原有健壮的代码要尽量不修改，而是通过扩展来实现。否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试，甚至是验收测试。开闭原则的使用，保证软件是通过扩展来实现业务逻辑的变化，而不是修改。因此，对于新增加的类，只需新增相应的测试类，编写对应的测试方法，只要保证新增的类是正确的就可以了。

### 2.2 开闭原则的应用

抽象化，多态是开闭原则的关键

比如说，需要替换或添加新功能的时候扩展子类

## 3 里氏替换原则

里氏替换原则的英文名称是：Liskov Substitution Principle，简称LSP。

### 3.1 里氏替换原则的定义

在面向对象的语言中，继承是必不可少的、优秀的语言机制，它主要有以下几个优点：

- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；

- 提高代码的可重用性；

- 提高代码的可扩展性；

- 提高产品或项目的开放性。

相应的，继承也存在缺点，主要体现在以下几个方面：

- 继承是入侵式的。只要继承，就必须拥有父类的所有属性和方法；

- 降低代码的灵活性。子类必须拥有父类的属性和方法，使子类受到限制；

- 增强了耦合性。当父类的常量、变量和方法修改时，必须考虑子类的修改，这种修改可能造成大片的代码需要重构。

从整体上看，继承的“利”大于“弊”，然而如何让继承中“利”的因素发挥最大作用，同时减少“弊”所带来的麻烦，这就需要引入“里氏替换原则”。里氏替换原则的定义有以下两种。

- 第一种定义

  If for each object o1 of type S there is an object o2 of type T such that forall programs P defined in terms of S,the behavior of P is unchanged wheno1 is substituted for o2 then T is a subtype of S.

  这个定义是最正宗的定义，意思是：如果对一个类型为S的对象o1，都有类型为T的对象o2，使得以S定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T是类型S的子类型。

- 第二种定义

  Functions that use pointers or references to base classes must be able touse objects of derived classes without knowing it.

  第二个定义意思是：所有引用基类的地方必须能透明地使用其子类对象。清晰明确地说明只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类；但是反过来则不可以，有子类的地方，父类未必就能适应。



