# schema与数据类型优化

## 1 数据类型优化

### 1.1 最小数据类型

应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围，如果无法确认哪个数据类型，就选择你认为不会超过范围的最小类型。

#### 1.1.1 案例

设计两张表，设计不同的数据类型，查看表的容量。因为4k存储，数据类型小的实际占用的空间更小

表结构：`id` 和 `name`，128 KB (131,072 字节)

```sql
CREATE TABLE `psn` (
    `id` INT(11) NOT NULL,
    `name` VARCHAR(10) NULL DEFAULT NULL,
    PRIMARY KEY (`id`)
)
COLLATE='utf8mb4_general_ci'
ENGINE=InnoDB
;
```

Java代码

```java
public class Test {
    public static void main(String[] args) throws Exception {
        Class.forName("com.MySQL.cj.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:MySQL://localhost:3306/tran?serverTimezone=UTC", "root", "123456");
        PreparedStatement pstmt = conn.prepareStatement("insert into psn values(?,?)");
        for (int i = 0; i < 20000; i++) {
            pstmt.setInt(1, i);
            pstmt.setString(2, i + "");
            pstmt.addBatch();
        }
        pstmt.executeBatch();
        conn.close();
    }
}
```

### 1.2 简单数据类型

简单数据类型的操作通常需要更少的CPU周期，例如

#### 1.2.1 整型替代字符型

整型值字符型操作代价更低，因为字符集和校对规则时字符比较比整型比较更复杂。

#### 1.2.2 使用Date存储日期和时间

使用MySQL自建类型而不是字符串来存储日期和时间

emp表使用date，emp2使用varchar

用时

[![image-20200808165843755](https://camo.githubusercontent.com/d7db0e74374d94fe4c000a7a08282db107fbab5434b2dc0673e18ae5bb4d6b77/68747470733a2f2f796579616e677368752d706963676f2e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d672f696d6167652d32303230303830383136353834333735352e706e67)](https://camo.githubusercontent.com/d7db0e74374d94fe4c000a7a08282db107fbab5434b2dc0673e18ae5bb4d6b77/68747470733a2f2f796579616e677368752d706963676f2e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d672f696d6167652d32303230303830383136353834333735352e706e67)

#### 1.2.3 用整型存储ip地址

用整型存储ip地址，使用函数进行转换

- INET_ATON：ip地址转为整型
- INET_NTOA：整型转为ip地址

[![image-20200808170115683](https://camo.githubusercontent.com/25d9c4f31127ecd6238b4c15bd315f300f2ea55dbd8755601d8f8d7a835aa222/68747470733a2f2f796579616e677368752d706963676f2e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d672f696d6167652d32303230303830383137303131353638332e706e67)](https://camo.githubusercontent.com/25d9c4f31127ecd6238b4c15bd315f300f2ea55dbd8755601d8f8d7a835aa222/68747470733a2f2f796579616e677368752d706963676f2e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d672f696d6167652d32303230303830383137303131353638332e706e67)

可以防止地址写错

[![image-20200808170154869](https://camo.githubusercontent.com/e5bc8dee8b180cd5bbe37ea03eb50aedd8bf33be40a28f45cf47e75221e8939f/68747470733a2f2f796579616e677368752d706963676f2e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d672f696d6167652d32303230303830383137303135343836392e706e67)](https://camo.githubusercontent.com/e5bc8dee8b180cd5bbe37ea03eb50aedd8bf33be40a28f45cf47e75221e8939f/68747470733a2f2f796579616e677368752d706963676f2e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f696d672f696d6167652d32303230303830383137303135343836392e706e67)

### 1.3 较量避免null

如果查询中包含可为NULL的列，对 MySQL 来说很难优化，因为可为 null 的列使得索引、索引统计和值比较都更加复杂，坦白来说，通常情况下 null 的列改为not null带来的性能提升比较小，所有没有必要将所有的表的 schema 进行修改，但是应该尽量避免设计成可为null的列。

### 1.4 实际细则

#### 1.4.1 整数类型

可以使用的几种整数类型：

- TINYINT：使用8位存储空间

- SMALLINT：使用 16 位存储空间
- MEDIUMINT：使用 24 位存储空间
- INT：使用 32 位存储空间
- BIGINT：使用 64 位存储空间

尽量使用满足需求的最小数据类型。

#### 1.4.2 字符和字符串类型

- char长度固定，即每条数据占用等长字节空间；最大长度是255个字符，适合用在身份证号、手机号等定长字符串。

- varchar可变程度，可以设置最大长度；最大空间是65535个字节，适合用在长度可变的属性。

- text不设置长度，当不知道属性的最大长度时，适合用text

按照查询速度：char > varchar > text

##### 1.4.2.1 varchar

varchar根据实际内容长度保存数据：

1. 使用最小的符合需求的长度。

2. varchar(n) n小于等于255使用额外一个字节保存长度，n>255使用额外两个字节保存长度。

3. varchar(5)与varchar(255)保存同样的内容，硬盘存储空间相同，但内存空间占用不同，是指定的大小 。

4. varchar在MySQL5.6之前变更长度，或者从255一下变更到255以上时时，都会导致锁表。

varchar应用场景：

1. 存储长度波动较大的数据，如：文章，有的会很短有的会很长

2. 字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度

3. 适合保存多字节字符，如：汉字，特殊字符等

##### 1.4.2.2 char

char是固定长度的字符串

1. 最大长度：255

2. 会自动删除末尾的空格

3. 检索效率、写效率会比varchar高，以空间换时间

char应用场景

1. 存储长度波动不大的数据，如：md5摘要

2. 存储短字符串、经常更新的字符串

#### 1.4.3 BLOB和TEXT类型

MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理，两者都是为了存储很大数据而设计的字符串类型。

- BLOB：二进制形式的长文本数据
- TEXT：字符形式的长文本数据

BLOB 和 TEXT 仅有的不同是BLOB类型存储的是二进制，没有排序规则或字符集，而 TEXT 类型有字符集和排序规则。

#### 1.4.4 datetime和timestamp

1. 不要使用字符串类型来存储日期时间数据

2. 日期时间类型通常比字符串占用的存储空间小

3. 日期时间类型在进行查找过滤时可以利用日期来进行比对

4. 日期时间类型还有着丰富的处理函数，可以方便的对时间类型进行日期计算

5. 使用int存储日期时间不如使用timestamp类型

##### 1.4.4.1 datetime

- 占用8个字节

- 与时区无关，数据库底层时区配置，对datetime无效

- 可保存到毫秒

- 可保存时间范围大

- 不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性

##### 1.4.4.2 timestamp

- 占用4个字节

- 时间范围：1970-01-01到2038-01-19

- 精确到秒

- 采用整形存储

- 依赖数据库设置的时区

- 自动更新timestamp列的值

##### 1.4.4.3 date

- 占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节
- 使用date类型还可以利用日期时间函数进行日期之间的计算

- date类型用于保存1000-01-01到9999-12-31之间的日期

#### 1.4.5 使用枚举ENUM代替常用字符串类型

有时可以使用枚举类代替常用的字符串类型

在MySQL中，`ENUM`是一个字符串对象，其值是从列创建时定义的允许值列表中选择的。

`ENUM`数据类型提供以下优点：

- 紧凑型数据存储，MySQL `ENUM`使用数字索引(1，2，3，…)来表示字符串值。
- 可读查询和输出。

MySQL 存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，MySQL 在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表。

语法：

```sql
CREATE TABLE table_name (
    ...
    col ENUM ('value1','value2','value3'),
    ...
);
```

案例：

假设我们必须存储优先级为：`low`, `medium` 和 `high` 的票据信息。 要将`priority`列分配给`ENUM`类型，请使用以下`CREATE TABLE`语句：

```sql
CREATE TABLE tickets (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    priority ENUM('Low', 'Medium', 'High') NOT NULL
);
```

`priority`列只接受三个`Low`, `Medium`, `High`值。 在后台，MySQL将每个枚举成员映射到数字索引。在这种情况下，`Low`，`Medium`和`High`分别映射到`1`,`2`和`3`。

插入`ENUM`值

```sql
INSERT INTO tickets(title, priority) VALUES ('ticket A', 'Low');
-- 使用数字索引
INSERT INTO tickets(title, priority) VALUES ('ticket B', 2);
```

#### 1.4.6 特殊类型数据

人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换。

案例：

见1.2.3

## 2 合理使用范式和反范式

### 2.1 范式

#### 2.1.1 优点

- 范式化的更新通常比反范式要快

- 当数据较好的范式化后，很少或者没有重复的数据

- 范式化的数据比较小，可以放在内存中，操作比较快

#### 2.2.2 缺点

通常需要进行关联

### 2.2 反范式

#### 2.2.1 优点

- 所有的数据都在同一张表中，可以避免关联

- 可以设计有效的索引

#### 2.2.2 缺点

表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失

### 2.3 企业一般混合使用

在企业中很少能做到严格意义上的范式或者反范式，一般需要混合使用：

- 在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。  在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。

- 另一个从父表冗余一些数据到子表的理由是排序的需要。

- 缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。

案例

- 范式设计

  ![image-20210122223538064](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210122223538064.png)

- 反范式设计

  ![image-20210122223555202](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210122223555202.png)

## 3 主键的选择

### 3.1 代理主键

与业务无关的，无意义的数字序列

### 3.2 自然主键

事物属性中的自然唯一标识

### 3.3 推荐使用代理主键

它们不与业务耦合，因此更容易维护
一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本

## 4 字符集的选择

字符集直接决定了数据在 MySQL 中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少 IO 操作次数。

字符集的选择：

1. 纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间。

2. 如果我们可以确定不需要存放多种语言，就没必要非得使用 UTF-8 或者其他 UNICODE 字符类型，这会造成大量的存储空间浪费。

3. MySQL 的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。

**utf8mb4**

## 5 存储引擎的选择

存储引擎的对比

![image-20210122223657398](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210122223657398.png)

## 6 适当的数据冗余

适当的数据冗余

1. 被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段。

2. 这样的场景由于每次 Join 仅仅只是为了取得某个小字段的值，Join 到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。

## 7 适当拆分

当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。
