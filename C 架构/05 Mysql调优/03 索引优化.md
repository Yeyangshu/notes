[TOC]

# 索引优化

## 1 索引的基本知识

### 1.1 索引的优点

1. 大大减少了服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表
3. 将随机io变成顺序io

### 1.2 索引的用处

1. 快速查找匹配WHERE子句的行
2. 从consideration中消除行，如果可以在索引之间进行选择，MySQL通常会使用找到最少行的索引
3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀查找行
4. 当有表连接的时候，则其他表索引行数据
5. 查找特定索引列的min和max值

### 1.3 索引的分类

### 1.4 索引的数据结构

### 1.5 索引匹配方式

![image-20200810224703468](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810224703468.png)

#### 1.5.1 全值匹配

全值匹配指的是和索引中的所有的列进行匹配

```sql
explain select * from staffs where name = 'July' and age = '23' and pos = 'dev';
```

![image-20200810230322818](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810230322818.png)

#### 1.5.2 匹配最左前缀

只匹配前面几个列

```sql
explain select * from staffs where name = 'July' and age = '23';
```

![image-20200810230617106](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810230617106.png)

```sql
explain select * from staffs where name = 'July';
```

![image-20200810230638970](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810230638970.png)

#### 1.5.3 匹配列前缀

可以匹配某一列的值的开头部分

```sql
explain select * from staffs where name like 'J%';
```

![image-20200810231037127](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810231037127.png)

编写sql时一定不要将通配符放在前面，即使有索引也不会使用

![image-20200810231058996](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810231058996.png)

#### 1.5.4 匹配范围值

```sql
explain select * from staffs where name > 'Mary';
```

![image-20200810231707357](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810231707357.png)

#### 1.5.5 精确匹配某一列并范围匹配另外一列

可以查询第一列的全部和第二列的部分

```sql
explain select * from staffs where name = 'July' and age > 25;
```

![image-20200810232018094](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810232018094.png)

```sql
explain select * from staffs where name = 'July' and pos > 25;
```

与上面对比，正确顺序是name，age，pos，此时用不到pos，只匹配name，所以pos > 25没有用，ref = constant。

![image-20200810232248497](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810232248497.png)

#### 1.5.6 只访问索引的查询

查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引

```sql
explain select name,age,pos from staffs where name = 'July' and age = 25 and pos = 'dev';
```

![image-20200810233017183](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200810233017183.png)

### 1.6  面试

## 2 哈希索引

### 2.1 基本知识

1. 什么是哈希索引？

   基于哈希表的实现，只有精确匹配索引所有列的查询才有效。（不能使用范围查找）

2. 在MySQL中，只有memory的存储引擎显式支持哈希索引

3. 哈希索引自身只需要存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引的查找的速度非常快

### 2.2 哈希索引的限制

1. 哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值避免读取行

   执行顺序：哈希值 -> 行指针 -> 数据

2. 哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序

3. 哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值

4. 哈希值支持等值比较查询，不支持任何范围查询

5. 访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突时，存储引擎必须遍历链表中的所有行指针，逐行进行比较，只到找到所有符合条件的行

6. 哈希冲突比较多的时候，维护代价也会很高

### 2.3 哈希案例

当需要存储大量的URL，并且根据URL进行搜索查找，如果使用B+树，存储的内容就会很大

```sql
select id from url where url = '';
```

也可以利用将URL使用CRC32做哈希，可以使用以下查询方式：

```sql
select id from url where url = '' and url crc = CRC32('');
```

此查询性能较高原因是使用体积很小的索引来完成查找

## 3 组合索引

当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，需要同时考虑如何更好的满足排序和分组的需要

### 3.1 组合索引案例

建立组合索引a, b, c

```sql
CREATE TABLE IF NOT EXISTS `test_index`(
  `id` int(4) NOT NULL AUTO_INCREMENT,
  `a` int(4) NOT NULL DEFAULT '0',
  `b` int(4) NOT NULL DEFAULT '0',
  `c` int(4) NOT NULL DEFAULT '0',
  `data` int(4) NOT NULL DEFAULT '0',
  PRIMARY KEY  (`id`),
  KEY `union_index` (`a`,`b`,`c`)
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC  DEFAULT CHARSET=binary;
```

**如果b是范围查找，不管c是不是索引列，都会忽略掉，不会参与运算**

1. 使用列a，`type:ref`表示引用查找，`key_len:4`表示索引长度为4

   ```sql
   explain select data from test_index where a = 1;
   ```

   ![image-20200811205124184](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205124184.png)

2. 使用列b，`type:ALL`表示全表查找，`key_len:NULL`表示没有索引，不能使用索引来加快查找速度

   ```sql
   explain select data from test_index where b = 1;
   ```

   ![image-20200811205152963](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205152963.png)

3. 使用列c，`type:ALL`表示全表查找，`key_len:NULL`表示没有索引，不能使用索引来加快查找速度

   ```sql
   explain select data from test_index where c = 1;
   ```

   ![image-20200811205211418](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205211418.png)

4. 使用列a和b，`type:ref`表示引用查找，`key_len:8`表示索引长度为8，`ref:const,const`，利用了a、b联合索引进行查找

   ```sql
   explain select data from test_index where a = 1 and b = 1;
   ```

   ![image-20200811205239715](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205239715.png)

   颠倒a和b顺序，使用列b和a，结果同上

   ```sql
   explain select data from test_index where b = 1 and a = 1;
   ```

   ![image-20200811205258860](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205258860.png)

5. 使用列a、b和c，`type:ref`表示引用查找，`key_len:12`表示索引长度为12，`ref:const,const,const`，利用了a、b、c联合索引进行查找

   ```sql
   explain select data from test_index where a = 1 and b = 1 and c = 1;
   ```

   ![image-20200811205321252](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205321252.png)

6. 使用列a和c，`type:ref`表示引用查找，`key_len:4`表示索引长度为4，`ref:const`，只使用了a索引进行查找

   ```sql
   explain select data from test_index where a = 1 and c = 1;
   ```

   ![image-20200811205337870](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205337870.png)

7. 使用列b和c，`type:ALL`表示全表查找，`key_len:NULL`表示没有索引，不能使用索引来加快查找速度

   ```sql
   explain select data from test_index where b = 1 and c = 1;
   ```

   ![image-20200811205351955](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205351955.png)

8. a=1 and b > 10 and c = 1，`type:range`表示范围查找，`key_len:8`表示索引长度为8，`ref:null`，利用了a、b联合索引进行查找

   ```sql
   explain select data from test_index where a = 1 and b > 1 and c = 1;
   ```

   ![image-20200811205410350](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205410350.png)

9. a=1 and b > 10 and c = 1，`type:ref`表示引用查找，`key_len:4`表示索引长度为4，`ref:const`，只使用了a索引进行查找

   ```sql
   explain select data from test_index where a = 1 and b like '%1' and c = 1;
   ```

   ![image-20200811205429030](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811205429030.png)

## 4 聚簇索引与非聚簇索引

### 4.1 聚簇索引

不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起

#### 4.1.1 优点

1. 可以把相关数据保存在一起
2. 数据访问更快，因为索引和数据保存在同一个树中
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

#### 4.1.2 缺点

1. 
2. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式（页分裂、页合并）
3. 更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置
4. 基于聚簇索引的表插入新行，或者主键被更新导致需要移动行的时候，可能面临也分裂的问题
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候

### 4.2 非聚簇索引

数据文件和索引文件分开存放

## 5 覆盖索引

### 5.1 基本介绍

1. 如果一个索引包含所有需要查询的字段，称之为覆盖索引
2. 不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值
3. 不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引



## 6  优化细节

1. 当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层

   不使用表达式

   ![image-20200811220529545](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811220529545.png)

   使用表达式

   ![image-20200811220609835](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20200811220609835.png)