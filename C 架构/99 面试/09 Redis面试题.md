## Redis面试题

## 1 Redis原理

### Redis为什么这么快

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞 I/O 多路复用机制

### Redis使用单线程的好处

1. 代码更清晰，处理逻辑更简单
2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 不存在多进程或者多线程导致的切换而消耗CPU

### Redis中如何控制多线程并发

select+poll模型（轮询）

epoll模型

1. 调用epoll_create建立一个epoll对象(在epoll文件系统中给这个句柄分配资源，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，

2. 调用epoll_ctl向epoll对象中（红黑树中）添加这100万个连接的套接字；

3. 调用epoll_wait收集发生事件的连接。当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回

![image-20210104220848714](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210104220848714.png)****

## 2 基本数据类型

### 2.1 Redis数据类型及应用场景（必考）

1. String
   - String类型：set nx 分布式锁
   - 数值INCR、DECR：抢购、秒杀、详情页、点赞、评论，对书数据库的操作完全有内存代替。
   - bitmap：
     - 登陆天数，名做key，位0和1做登录数据
     - 活动礼物：分辨冷热用户，日期做key，位做用户是否登录，bittop or去重，bitcount统计
2. List：可以实现栈、队列、数组、单播队列，聊天系统
3. Hash：详情页、的点赞、收藏
4. Set：无序，随机事件SRANDMEMBER，用于抽奖
5. Sorted_set(ZSet)：有序，可以做排行榜

### 2.2 sortedSet的底层数据结构（必考）

排行榜功能的实现：使用Redis的zset；zset的底层数据结构是什么样的；除了Redis的zset还有什么其他的数据结构可以实现这个功能

跳表

## 3 缓存击穿，缓存穿透，缓存雪崩

### 3.1 解释一下缓存击穿，缓存穿透，缓存雪崩，如何解决这些问题

正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透。

### 3.2 布隆过滤器

## 4 缓存LRU

### Redis的数据过期策略（必考）

业务逻辑：key的有效期

业务运转：内存有限

### Redis的数据一致性问题？

一致性问题还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。前提是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。

另外，我们所做的方案从根本上来说，只能降低不一致发生的概率。因此，有强一致性要求的数据，不能放缓存。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

### 缓存和数据库双写一致性问题

### Redis key的时间有效期会随着访问延长吗？

假设key的有效期设置为10s，9s的时候别人读了它，重新计时时长，证明他是热数据？

答：不对

1. key的有效期不会延长

   ```shell
   # 先给k1设置20s有效期
   127.0.0.1:6379> set k1 aa ex 20
   OK
   127.0.0.1:6379> ttl k1
   (integer) 14
   127.0.0.1:6379> ttl k1
   (integer) 2
   127.0.0.1:6379> ttl k1
   (integer) 0
   # k1时间过期
   127.0.0.1:6379> ttl k1
   (integer) -2
   # 有效期时间之后key不存在
   127.0.0.1:6379> get k1 
   (nil)
   ```

2. 在有效期内发生写会剔除有效期时间，EXPIRE

   ```shell
   # 设置k1
   127.0.0.1:6379> set k1 aa
   OK
   # 此时k1有效期是永久值
   127.0.0.1:6379> ttl k1
   (integer) -1
   # 人为为k1设置时间，30s
   127.0.0.1:6379> EXPIRE k1 30
   (integer) 1
   # 倒计时
   127.0.0.1:6379> ttl k1
   (integer) 28
   # 存活时间内写新值
   127.0.0.1:6379> set k1 bbb
   OK
   # k1有效期时间被剔除，重新为永久值
   127.0.0.1:6379> ttl k1
   (integer) -1
   # 查询是新值
   127.0.0.1:6379> get k1 
   "bbb"
   ```

### 主动过期、被动过期

为什么这个设置主动和被动两种方式？

牺牲一下内存，保证Redis的性能

## 5 数据库持久化

### 5.1 Redis的持久化机制（必考）

## 6 主从复制

## 7 集群

### 集群环境下如何保证数据一致性问题，解释一下一致性哈希

#### 一致性哈希的基本概念

一致性哈希是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器的时候，能够尽可能小的改变服务器请求与处理请求服务器之间的映射关系。

一致性哈希算法也是使用取模的概念，对 2^32 取模。一致性哈希算法将整个哈希空间组织成一个虚拟的圆环，整个哈希环如下。

![image-20210106204018662](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210106204018662.png)

假设我们有 4 台缓存服务器，服务器 A、服务器 B、服务器 C，服务器 D，那么，在生产环境中，服务器有自己的 IP 地址或主机名，我们使用它们各自的IP地址或主机名作为关键字进行哈希计算，使用哈希后的结果对 2^^32^ 取模，可以使用如下公式示意：

```
hash（服务器A的IP地址） %  2^32
```

通过上述公式算出的结果一定是一个 0 到 2^^32^ -1 之间的一个整数，使用算出的这个整数，代表服务器 A，服务器 A 就可以映射到这个环上。以此类推，将各个服务器使用类似的 Hash 算式进行一个哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用 IP 地址哈希后在环空间的位置如下：

![image-20210106204416275](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210106204416275.png)

如下算法定位数据访问到相应服务器： **将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器**

例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：

![image-20210106204532446](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210106204532446.png)

根据一致性 Hash 算法，数据 A 会被定为到 Node A 上，B 被定为到 Node B 上，C 被定为到 Node C 上，D 被定为到 Node D上。



**为什么hash一致性的数据空间范围是2^32次方？**

因为，java中int的最大值是2^^31^-1最小值是-2^^31^,2^^32^刚好是无符号整形的最大值；int的最大值最小值范围设定是因为一个int占4个字节，一个字节占8位，二进制中刚好是32位。

#### 一致性Hash算法的容错性和可扩展性

现假设 Node C 不幸宕机，可以看到此时对象 A、B、D 不会受到影响，只有 C 对象被重定位到 Node D。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：

![image-20210106204903597](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210106204903597.png)

下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：

![image-20210106204948316](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210106204948316.png)

此时对象 Object A、B、D 不受影响，只有对象 C 需要重定位到新的 Node X ！一般的，在一致性 Hash 算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。

一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。

### Redis集群种类：主从模式、cluster模式及其应用

## 8 分布式锁

### 利用Redis实现分布式锁