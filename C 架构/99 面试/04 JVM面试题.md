# JVM面试题



## 1 类加载过程

### 为什么要搞双亲委派？

主要是为了安全，反证法

例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。

## 2  JVM运行时数据区

1、jvm内存模型，以及这些空间的存放内容 

2、堆内存划分的空间，如何回收这些内存对象，有哪些回收算法

3、jvm调优，如何解决线上gc问题

4、class初始化过程

5、内存溢出的原因，如何排查线上问题

6、jvm有哪些垃圾回收器，

7、类加载模型

8、JVM为什么要增加元空间？

9、堆G1垃圾收集器有了解么，有什么特点

## Java内存模型 JMM

### Java 中共享变量的内存可见性问

## 3 GC与调优

### java中会存在内存泄漏吗

CMS和G1了解吗

CMS解决什么问题

CMS回收停顿了几次，说一下回收的过程？

java栈什么时候会内存溢出，java堆呢，说一种场景？



### Java是解释还是编译执行？

33页

Java是混合模式：解释器 + 热点代码编译（JIT，Just In Time）

指令：

- -Xmixed：默认混合模式
- -Xint：
- -Xcomp







### 为什么要实现双亲委派模型？

安全

### 解释一下对象的创建过程

1. 第一步将class 加载到内存

2. 第二步linking的过程
   - verification校验
   - preparation把类的静态变量设置默认值
   - resolution做解析
3. 类的初始化吧静态变量设为初始值同时执行静态语句块
4. 申请对象内存
5. 成员变量赋默认值
6. 调用构造方法`<init>` 
   - 成员变量顺序赋初始值
   - 执行构造方法语句

### 对象在内存中的存储布局？

对象的内存布局分为两类：

1. 普通对象

   - 对象头，在Hotspot里面称为markword，8个字节

   - ClassPointer指针：-XX:+UseCompressedClassPointers为4个字节，不开启为8个字节

   - 实例数据：

     - 引用类型：-XX:+UseCompressedOops为四个字节，不开启为8个字节，Oops（Ordinary Object Pointers）

     - 成员变量大小

       | Primitive Type | Memory Required(bytes) |
       | -------------- | ---------------------- |
       | boolean        | 1                      |
       | byte           | 1                      |
       | short          | 2                      |
       | char           | 2                      |
       | int            | 4                      |
       | float          | 4                      |
       | long           | 8                      |
       | double         | 8                      |

   - Padding对齐，是8的倍数

   普通对象，首先有一个对象头markword，8个字节，第二这个对象是属于哪个class的，ClassPointer指针指向你要的class对象，实例数据就是成员变量还有引用类型，第四个Padding对齐，算出来正好是15个字节，64位机器按照块来读取，所以是8的倍数

2. 数组对象

   - 对象头，8
   - ClassPointer指针
   - 数组长度：4字节
   - 数组数据
   - 对齐8的倍数

### 对象头具体包括什么？

简单参考文档：https://www.jianshu.com/p/91e398d5d17c

每个版本实现都不一样，markword的结构，定义在markOop.hpp文件

MarkWord里面有什么？MarkWord记录了对象和锁有关的信息，第一锁信息代表对象有没有被锁定，，第二GC的标记记录了分代年龄

### 对象怎么定位？

摘自《深入理解Java虚拟机》

创建对象自然是为了后续使用该对象，Java程序会通过栈上的refrence数据来操作栈上的具体对象。refrence类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以访问对象方式也是由虚拟机实现而定的，直流的访问方式有两种：

1. 句柄池

   如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，refrence中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息，**有图**

2. 直接指针

   如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，refrence中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要间接访问的开销，有图

这两种访问方式各有优势，使用句柄来访问最大的好处就是refrence中存储的是稳定句柄地址，在对象被移动（垃圾回收的时候移动对象是非常普遍的）时只会改变句柄中的实例数据指针，而refrence本身不需要被修改。使用直接指针来访问的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。Hotspot主要使用第二种方式进行对象定位，但是从整个软件开发的范围来看，在各类语言、框架中使用句柄来访问的情况也是非常常见的。

### 对象怎么分配？

### Object o = new Object在内存中占用了多少字节？

书58-59

### 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存

不会，在下一个垃圾回调周期中，这个对象将是被可回收的。

也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。