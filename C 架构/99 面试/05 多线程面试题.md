# 多线程面试题

## 1 基本概念

### 进程与线程的区别

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

![image-20201230225950645](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230225950645.png)

### 并行和并发

![image-20201230230347405](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230230347405.png)

并发是两个队列**交替**使用一台咖啡机，并行是两个队列**同时**使用两台咖啡机，并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。

![image-20201230235241196](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230235241196.png)

### 线程的生命周期和状态

线程在运行的生命周期中只能有下面6中状态：

![image-20201230230731308](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230230731308.png)

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

![image-20201230230838900](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230230838900.png)

### Java中的wait和sleep的区别与联系

- 两者最主要的区别在于：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- `wait()` 通常被用于线程间交互/通信，`sleep() `通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify() `或者 `notifyAll()` 方法。`sleep() `方法执行完成后，线程会自动苏醒。或者可以使用 `wait(long timeout)` 超时后线程会自动苏醒。



### 多线程之间是如何通信的

jmm模型

## 同步

### synchronized作用

`synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

### synchronized关键字加在静态方法和实例方法的区别

1. 修饰实例方法

   作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

   ```java
   synchronized void method() {
     //业务代码
   }
   ```

2. 修饰静态方法

   也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

   ```java
   synchronized void staic method() {
       //业务代码
   }
   ```

3. 修饰代码块

   指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

   ```java
   synchronized(this) {
     //业务代码
   }
   ```

**总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能！

### synchronized关键字的底层原理

synchronized 关键字底层原理属于 JVM 层面。

1. synchronized 同步语句块

   ![](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230233011317.png)

   `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

   - 在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

   - 在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

2. synchronized 修饰方法

   使用的是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### 锁升级

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态

### synchronized和ReentrantLock的区别（必考）

- ReentrantLock具备synchronized的功能

  两者都是可重入锁

- ReentrantLock更灵活
- ReentrantLock增加一些高级功能
  - 等待可中断
  - 可实现公平锁
  - 可实现选择性通知

ReentrantLock获得锁和释放锁的操作更加灵活，且具备独立的条件监视器，等待和唤醒线程的操作也更方便和多样化，在多线程环境下，ReentrantLock的执行效率比synchronized高。

### volatile关键字（必考）

1. CPU 缓存模型

   CPU缓存则是为了解决CPU处理速度和内存处理速度不对等的问题。

   先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 **内存缓存不一致性的问题** ！

   CPU 为了解决内存缓存不一致性问题通过制定缓存一致协议来解决。

   CPU和内存速度之差 -> CPU缓存 -> 缓存不一致问题 -> 缓存一致性协议

2. JMM（Java 内存模型）

   ![image-20201230234454095](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201230234454095.png)

`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。

### synchronized 关键字和 volatile 关键字的区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **`volatile` 关键字**是线程同步的**轻量级实现**，所以**`volatile `性能肯定比`synchronized`关键字要好**。但是**`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块**。
- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。**
- **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**



## Atomic AQS

### Atomic类如何保证原子性（CAS操作）（必考）

### AQS源码

AQS的核心就是共享资源state，和一个监控这个state的双向链表，每个列表里面有一个节点，节点装的是线程

### countdownlatch的用法





## ThreadLocal

### ThreadLocal的底层实现形式及实现的数据结构？

ThreadLocal有一个map，拿到当前线程，把value放进map

##  线程池

	（1）Executor提供了几种线程池
	
	（2）线程池的参数
	
	（3）拒绝策略
	
	（4）任务放置的顺序过程
	
	（5）任务结束后会不会回收线程
	
	（6）未使用的线程池中的线程放在哪里
	
	（7）线程池线程存在哪
	
	（8）cache线程池会不会销毁核心线程

### Java多线程的几种状态及线程各个状态之间是如何切换的

### 如何在方法栈中进行数据传递？

为什么要使用线程池（必考）

核心线程池ThreadPoolExecutor的参数（必考）

ThreadPoolExecutor的工作流程（必考）



### 服务器CPU数量及线程池数量的关系

线程池大小与处理器的利用率之比可以使用下面的公式进行估算

N threads = N CPU * U CPU * (1 + W /C)





### 聊一聊容器？

容器分为两大类Collection、Map，Collection又分为三大类：List、Set和Queue，Array可以取其中一个，Set值是唯一的，不会有重复元素，Queue就是队列，有进有出，往这个队列里取数据的时候它和List、Set都不一样，它实现了很多多线程的访问方法（比如put阻塞式的放，take阻塞式的取），这些是List和Set没有的。队列的最主要原因是为了实现阻塞队列，初衷就是为了线程池、高并发做准备的。

线程友好的接口，实现Queue：

- offer：相当于add，返回boolean值
- peek：取但是不删除元素
- poll：取并且删除元素



#### 面试题：Queue和List区别？
  - Queue接口添加了很多对线程友好的API offer peek poll
  - Queue子类型BlockingQueue又添加了put 和 take
  - put take -> 实现了阻塞操作

### 