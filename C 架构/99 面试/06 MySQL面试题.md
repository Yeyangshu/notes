# MySQL

## 1 事务

### 事务的基本要素

ACID

A 原子性：事务是最小的执行单位，不允许被分割。要么成功，要么失败。

C 一致性：执行事务的前后，数据保持一致。

I 隔离性：并发放稳数据库时，一个用户的事务不被其他事物所干扰，各并发事物之间数据库是独立的。

D 持久性：一个事务提交后，它对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其具有任何影响。

### 事务隔离级别（必考）

- READ-UNCOMMITTED（读未提交）：允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- READ-COMMITTED（读已提交）：允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- REPEATABLED-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- SERIALIZABLE（序列化）：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

MySQL默认隔离级别：REPEATABLED-READ（可重复读）

### 并发事务带来的问题，如何解决

- 脏读：**:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- 幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复度和幻读区别：**不可重复读的重点是修改，幻读的重点在于新增或者删除。

使用悲观锁和乐观锁解决。

InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下，允许应用使用 Next-Key Lock 锁算法来避免幻读的产生。所以说虽然 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** ，但是可以通过应用加锁读（例如 `select * from table for update` 语句）来保证不会产生幻读，而这个加锁读使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 **SERIALIZABLE(可串行化)** 隔离级别。

InnoDB存储引擎通过多版本并发控制（MVCC）解决幻读问题

### 有多少种事务失效的场景，如何解决？

### 数据库锁的理解

- MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）
- InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

MyISAM的表级锁有两种模式：**表共享读锁（Table Read Lock）\**和\**表独占写锁（Table Write Lock）**。

InnoDB的行锁模式及加锁方法

- 共享锁（s）

  又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

- 排他锁（x）

  又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。\

## 2 存储引擎

innodb和myisam的区别

## 2 索引

什么是索引？

### MySQL为什么选择B+树作为它的存储结构，为什么不选择Hash、二叉、红黑树？

Hash：不适合范围查询

二叉树：深度不可控

红黑树：插入效率比较低或者树的深度无法控制

B树：同时存储key+data，浪费空间，数据量大的时候，会增加深度和IO次数，影响查询性能

B+树：非叶子节点存储key，叶子节点存储key+data

### 索引B+树的叶子节点都可以存哪些东西（必考）

- MyISAM存储的是数据的地址

- InnoDB存储的是id+data

### 查询在什么时候不走（预期中的）索引（必考）

## 3 日志

### binlog，redolog，undolog都是什么，起什么作用

- redo  log 重做日志：确保日志的**持久性**，防止在发生故障，脏页未写入磁盘。重启数据库会进行redo log执行重做，达到事务一致性
- undo  log 回滚日志：保证数据的原子性，记录事务发生之前的一个版本，用于回滚，innodb事务可重复读和读取已提交隔离级别就是通过mvcc+undo实现
- bin log 二进制日志：记录所有的逻辑，并且采用追加写的方式，用于主从复制，实现主从同步

### 为什么redo log两阶段提交？

**为了保证数据的一致性**，redo log 和 Binlog 数据一致，不会发生数据错乱。

## 4 数据库锁

### MySQL的乐观锁和悲观锁，锁的种类

### 如何用sql实现乐观锁和悲观锁

## 5 SQL

Char、Varchar、Varbinary 存储字符的区别？

### Union和union all有什么区别

### Datetime、Timestamp 存储时间的区别？

数据库临时表有没有用过，是怎么用的？

Float、Decimal 存储金额的区别？

## 6 SQL优化

对Explain参数及重要参数的理解？

如何优化sql，查询计划的结果中看哪些些关键数据

### 如何解析sql语句；即explain关键字的使用

sql如何优化

## 7 主从复制、读写分离

### MySQL主从模式的实现

### MySQL的主从同步原理，MySQL主从复制主要有几种模式

原理：

1. master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；
2. slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件
3. 同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

也就是说：

- 从库会生成两个线程,一个I/O线程，一个SQL线程;
- I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;
- 主库会生成一个log dump线程,用来给从库I/O线程传binlog;
- SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;

主从复制主要模式

- 一主一从
- 主主复制
- 一主多从
- 多主一从
- 联级复制

## 8 分库分表

MySQL如何分库分表