# 评估算法优劣

## 1 评估算法优劣的核心指标是什么？

- 时间复杂度（流程决定）
- 额外空间复杂度（流程决定）
- 常数项时间（实现细节决定）

### 1.1 什么是时间复杂度？时间复杂度怎么估算？

- 常数时间的操作

- 确定算法流程的总操作数量与样本数量之间的表达式关系

- 只看表达式最高阶项的部分

#### 1.1.1 什么是常数时间操作？

如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。

常见的常数时间的操作：

- 常见的算术运算（+、-、*、/、% 等）
- 常见的位运算（>>、>>>、<<、|、&、^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

总之，执行时间固定的操作都是常数时间的操作；反之，执行时间不固定的操作，都不是常数时间的操作。

#### 1.1.2 如何确定算法流程的总操作数量与样本数量之间的表达式关系？

如何确定算法流程的总操作数量与样本数量之间的表达式关系？

1. 想象该算法流程所处理的数据状况，要按照最差情况来。
2. 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
3. 如果数据量为N，看看基本动作的数量和N是什么关系。

#### 1.1.3 如何确定算法流程的时间复杂度？

当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。

记为：O(忽略掉系数的高阶项)

#### 1.1.4 时间复杂度的意义

抹掉了好多东西，只剩下了一个最高阶项啊…那这个东西有什么意义呢？

时间复杂度的意义在于：

当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。

这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

#### 1.1.5 时间复杂度的估算

### 1.2 额外空间复杂度

你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。

- 作为输入参数的空间，不算额外空间。

- 作为输出结果的空间，也不算额外空间。

因为这些都是必要的、和现实目标有关的。所以都不算。但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。

如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

### 1.3 常数项时间

我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。

难道同样时间复杂度的流程，在实际运行时候就一样的好吗？当然不是。

时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。

#### 1.3.1 算法流程的常数项的比拼方式

放弃理论分析，生成随机数据直接测。

为什么不去理论分析？

不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。

比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。

所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。

### 1.4 最优解

一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。

一般说起最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。

### 1.5 常见的时间复杂度

排名从好到差：

- O(1) 
- O(logN) ：也叫对数时间，这样的算法包括二分查找
- O(N) ：也叫限线性时间，这样的算法包括简单查找
- O(N*logN) ：这样的算法包括快速排序—一种速度较快的算法
- O(N^2)  O(N^3)  …  O(N^K)：这样的算法包括选择排序—一种速度较慢的算法
- O(2^N)  O(3^N)  …  O(K^N)
- O(N!)：旅行商问题一种非常慢的算法

![image-20210113231712959](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210113231712959.png)

## 2 时间复杂度的估算

### 2.1 选择排序

首先，找到数组中的最小的元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。其次，再剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将这个数组排序。这种方法叫选择排序，因为它不断的选择剩余元素之中的最小者。

![image-20210117200420296](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210117200420296.png)

过程：

- arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。

- arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。

- arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。

- …

- arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。


估算：

很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般

所以，总的常数操作数量：n\*(n-1)\*(n-2)\*...\*2\*1= a\*(N^2) + b\*N + c (a、b、c都是常数)

所以选择排序的时间复杂度为O(N^2)。

![image-20210113232635690](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20210113232635690.png)

### 2.2 冒泡排序

过程：

在arr[0～N-1]范围上：

- arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置

- 在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置

- 在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置

- …

- 最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置


估算：

很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般

所以，总的常数操作数量为 a\*(N^2) + b\*N + c (a、b、c都是常数)

所以冒泡排序的时间复杂度为O(N^2)。

### 2.3 插入排序

当前索引左边的所有元素都是有序的，但他们的最终位置还不确定。为了给更小的元素腾出空间，它们可能会被移动。当索引达到数组的最右端时，数组排序就完成了。

过程：

- 想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。

- 想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1]<arr[0]，就交换。否则什么也不做。

- …

- 想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

- 最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。


估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。

你发现了吗？

如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。

很明显，在最差情况下，如果arr长度为N，插入排序的每一步常数操作的数量，还是如等差数列一般

所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)

所以插入排序排序的时间复杂度为O(N^2)。



### 2.4 交换两个位置，位运算

内存必须是不同的，值可以相等

如果是同一个，就为0

```java
// 不能是一个位置
// arr[i] = arr[0] ^ arr[0];
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j];
arr[i] = arr[i] ^ arr[j];
```
