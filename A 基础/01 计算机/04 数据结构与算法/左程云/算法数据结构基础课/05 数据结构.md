# 数据结构

## 1 链表

### 1.1 单向链表

单向链表节点结构（可以实现成范型）

```java
public class Node {
    public int value;
    public Node next;
    public Node(int data) {
        value = data;
    }
}
```

### 1.2 双向链表

双向链表节点结构

```java
public class DoubleNode {
    public int value;
    public DoubleNode last;
    public DoubleNode next;

    public DoubleNode(int data) {
        value = data;
    }
}
```

### 1.3 单向链表和双向链表最简单的练习

链表相关的问题几乎都是coding问题

1. 单链表和双链表如何反转

2. 把给定值都删除

## 2 栈和队列

### 2.1 逻辑概念

栈：数据先进后出，犹如弹匣

队列：数据先进先出，好似排队

### 2.2 栈和队列的实际实现

- 双向链表实现栈和队列

- 数组实现栈和队列

### 2.3 栈和对列常见面试题

1. 怎么用数组实现不超过固定大小的队列和栈？（DataStructure04_StackAndQueue_RingArray）

   - 栈：正常使用
   - 队列：环形数组

2. 实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能  （DataStructure05_StackAndQueue_GetMinStack）

   1. pop、push、getMin 操作的时间复杂度都是 O(1)。

   2. 设计的栈类型可以使用现成的栈结构。

   Code方案一：准备两个栈，Data 栈和 Min 栈，Data 正常压栈出栈，Min 栈存 Data 栈最小值

   ![image-20201206110207633](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201206110207633.png)

   Code方案二：准备两个栈，Data 栈和 Min 栈，Data 正常压栈出栈，Min 栈存 Data 栈最小值，Data 大于 Min 栈顶时不压栈，时间换空间，弹栈时需要复杂的逻辑判断

   ![image-20201206112036658](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201206112036658.png)

3. 实现队列结构

   - 如何用栈结构实现队列结构（DataStructure06_StackAndQueue_TwoStacksImplementQueue）

     复制栈剩余数据至 Help 栈，交换 Help 和 Data

     ![image-20201206112848347](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201206112848347.png)

   - 如何用队列结构实现栈结构（DataStructure07_StackAndQueue_TwoQueueImplementStack）

     注意点：

     - pop 为空的时候才能导数据
     - 必须一次导完

     ![image-20201206113643872](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201206113643872.png)

## 3 哈希表/有序表

### 3.1 哈希表

1)哈希表在使用层面上可以理解为一种集合结构

2)如果只有key，没有伴随数据value，可以使用HashSet结构

3)如果既有key，又有伴随数据value，可以使用HashMap结构

4)有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事 

5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大

6)放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小

7)放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节



哈希表，增、删、改、查在使用时时间复杂度为 O(1)，哈希表基本类型及其包装类，String按值传递，非基础类型按引用传递



### 3.2 有序表

1. 有序表在使用层面上可以理解为一种集合结构

2. 如果只有key，没有伴随数据value，可以使用TreeSet结构

3. 如果既有key，又有伴随数据value，可以使用TreeMap结构

4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事

5. 有序表把key按照顺序组织起来，而哈希表完全不组织

6. 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同

7. 放入如果是基础类型，内部按值传递，内存占用就是这个东西的大小

8. 放入如果不是基础类型，内部按引用传递，内存占用是8字节

9. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度 



方法

```java
1)void put(K key, V value)
将一个(key，value)记录加入到表中，或者将key的记录 更新成value。

2)V get(K key)
根据给定的key，查询value并返回。

3)void remove(K key)
移除key的记录。 

4)boolean containsKey(K key)
询问是否有关于key的记录。

5)K firstKey()
返回所有键值的排序结果中，最小的那个。

6)K lastKey()

返回所有键值的排序结果中，最大的那个。
7)K floorKey(K key)
返回<= key 离key最近的那个

8)K ceilingKey(K key）
返回>= key 离key最近的那个
```

### 3.3 哈希表和有序表的原理

记住：

**哈希表在使用时，增删改查时间复杂度都是O(1)**

**有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)**