# 递归

分而治之（divide and conquer，D&C）—递归问题解决方法

1. 找出基线位置，这种条件必须尽可能简单
2. 不断将问题分解（或者缩小规模），直到符合基线条件

怎么从思想上理解递归

怎么从实际实现的角度出发理解递归

## 1 案例

求数组arr[L..R]中的最大值，怎么用递归方法实现。

1）将[L..R]范围分成左右两半。左：[L..Mid] 右[Mid+1..R]

2）左部分求最大值，右部分求最大值

3） [L..R]范围上的最大值，是max{左部分最大值，右部分最大值}

注意：2）是个递归过程，当范围上只有一个数，就可以不用再递归了

## 2 递归的脑图和实际实现

对于新手来说，把调用的过程画出结构图是必须的，这有利于分析递归。递归并不是玄学，递归底层是利用系统栈来实现的。任何递归函数都一定可以改成非递归。

![image-20201206162148014](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201206162148014.png)

## 3 Master公式

形如

T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)

的递归函数，可以直接通过Master公式来确定时间复杂度

- 如果 log(b,a) < d，复杂度为O(N^d)

- 如果 log(b,a) > d，复杂度为O(N^log(b,a))

- 如果 log(b,a) == d，复杂度为O(N^d * logN)

> 总共有 N 规模的问题，把 N 拆分成等量小的 N/b 子问题，调用了 a 次，除去子问题之外的时间复杂度是 O(N^d)，上面的例子总规模是 N，被等拆分成 L/R=N/2，b=2，调用了两次 process 方法，所以 a=2，除去 process 方法的时间复杂度是 O(1)=O(N^0)，d=0，代入上面公式，复杂度为 O(N^log(b,a))=O(N)。



![image-20201206162757834](https://yeyangshu-picgo.oss-cn-shanghai.aliyuncs.com/img/image-20201206162757834.png)

