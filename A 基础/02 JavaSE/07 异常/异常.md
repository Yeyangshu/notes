# 异常

## 1 异常概述

Throwable是所有异常类型的基类，该类有两个直接子类

- Error
- Exception
  - RuntimeException：由于程序错误导致的异常属于RuntimeException
  - 包含其他异常：程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常

## 2 异常的分类

可控式异常

运行时异常

## 3 获取异常信息

## 4 处理异常

## 5 抛出异常

## 6 自定义异常

## 7 异常使用原理

## 8 经典样例









# Java编程思想异常

Java的基本理念是“结构不佳的代码不能运行”。

发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。

## 1 概念

## 2 基本异常throw

异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。

使用new在堆上创建异常对象，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是**异常处理程序。**

简单例子，**抛出一个异常**

```java
if (t == null) {
    throw new NullPoninterException();
}
```

抛出了异常，在当前环境中就不必为这个问题操心，它将会在别的地方得到处理。

异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。

### 1.1 异常参数

与使用Java的其他对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储开建的分配和构造器的调用。所有标准异常类都有两个构造器：一个默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器。

能跑出任意类型的Throwable对象是异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象内部或者用异常类的名字来暗示。上一层环境通过这些信息来决定如何处理异常。

```
Throwable
```

## 3 捕获异常try/catch

要明白异常是如何被捕获的，首先必须理解监控区域（guarded region）的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

### 3.1 try块

如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望此方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种（可能产生异常的）方法调用，所以称为try块。

```java
try {
    // Code that might generate exceptions
}
```

### 3.2 异常处理程序catch

抛出的异常必须在某处得到处理。这个地点就是**异常处理程序**，而且要针对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在try块之后，以关键字catch表示：

```java
try {
    // Code that might generate exceptions
} catch(Type type) {
    // Handle exceptions of type
}
```

异常处理程序必须紧跟在try块之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch子句执行，此时认为异常得到了处理。

注意在try块的内部，许多不同的方法调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。

## 4 创建自定义异常

要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。

## 5 异常说明throws

Java鼓励人们把方法可能抛出的异常告知此方法的客户端程序员。这是一种优雅的做法，它使得调用者能确切知道写什么样的代码可以捕获所有最潜在的异常。Java提供了相应的预发（并强制使用了这个语法），似的你能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行响应的处理。这就是**异常说明**。它属于方法声明的一部分，紧跟在形式参数列表之后。

关键字：throws，后面接一个所有潜在异常类型的列表

```java
void f() throws TooBig, TooSmall {
    // ...
}
```

就表示此方法不会抛出任何异常。



代码必须与异常说明保持一致。如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你：要么处理异常，要么就在异常说明中表明此方法将产生异常。

就像

```java
public class FileInputStream extends InputStream {
    public FileInputStream(String name) throws FileNotFoundException {
        this(name != null ? new File(name) : null);
    }
}
```

## 7 Java标准异常

Throwable用来表示任何可以作为异常被抛出的类。Throwable对象可分为两种类型：

- Error用来表示编译时和系统错误
- Exception是可以被抛出的基本类型



# Java核心技术异常

## 1 Java异常分类

Throwable是所有异常类型的基类，

- Error
- Exception
  - RuntimeException：由于程序错误导致的异常属于RuntimeException
  - 包含其他异常：程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常

### 受查异常和非受查异常

Java语言规范将派生于Error或RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他的异常称为受查（checked）异常。

#### 受查异常（非Error或RuntimeException类）

受查异常会在编译时被检测。

如果一个方法中的代码会抛出受查异常，则该方法必须包含异常处理，即 try-catch 代码块，或在方法签名中用 throws 关键字声明该方法可能会抛出的受查异常，否则编译无法通过。如果一个方法可能抛出多个受查异常类型，就必须在方法的签名处列出所有的异常类。

案例：此时编译器会报错

```java
private static void readFile(String filePath) {
    File file = new File(filePath);
    String result;
    BufferedReader reader = new BufferedReader(new FileReader(file));
    while ((result = reader.readLine()) != null) {
        System.out.println(result);
    }
    reader.close();
}
```



通过 throws 关键字声明可能抛出的异常

```java
private static void readFile(String filePath) throws IOException {
    File file = new File(filePath);
    String result;
    BufferedReader reader = new BufferedReader(new FileReader(file));
    while ((result = reader.readLine()) != null) {
        System.out.println(result);
    }
    reader.close();
}
```

try-catch 处理异常

```java
private static void readFile(String filePath) {
    File file = new File(filePath);
    String result;
    BufferedReader reader;
    try {
        reader = new BufferedReader(new FileReader(file));
        while ((result = reader.readLine()) != null) {
            System.out.println(result);
        }
        reader.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

#### 非受查异常

非受查异常不会在编译时被检测。JAVA 中 Error 和 RuntimeException 类的子类属于非受查异常

## 2 声明异常

一个方法不仅要告诉编译器将要返回什么类型的值，还要告诉编程器可能返回的错误。

方法应该在其首部申明所有可能抛出的异常。

```java
public class FileInputStream extends InputStream {
    public FileInputStream(String name) throws FileNotFoundException {
        this(name != null ? new File(name) : null);
    }
}
```

这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException异常。如果发生了这种情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException类对象。如果这个方法真的抛出了这样一个对象，运行时系统就会开始搜索异常处理器，以便知道如何处理FileNotFoundException对象。

下面4中情况应该抛出异常：

1. 调用一个抛出已检查异常的方法，例如FileInputStream构造器。
2. 程序运行过程中发现错误，并且利用throw语句抛出一个已检查异常。
3. 程序出现错误，例如，a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的未检查异常。
4. Java虚拟机和运行时库出现的内部错误。



使用异常的时机

- 异常处理不能代替简单的测试

  只有在异常的时候使用异常机制

- 不要过分的细化异常

  目标：将正常处理与错误处理分开

- 利用异常层次结构

  不要只抛出

- 不要压制异常

# 面试题

**5. throw 和 throws 的区别是什么？**

throw 关键字用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。
throws 关键字用在方法签名处，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。




